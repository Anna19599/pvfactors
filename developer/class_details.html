
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Details on classes and modules &#8212; pvfactors 0.1.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s New" href="../whatsnew.html" />
    <link rel="prev" title="pvfactors: Jupyter notebook guide" href="pvfactors_demo.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/sp_2014_logo_black_orange_rgb.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SunPower&repo=pvfactors&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theory</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer docs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="how_to.html">How to use the model for single-point calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pvfactors_demo.html">pvfactors: Jupyter notebook guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Details on classes and modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-array-class">The <em>Array</em> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-timeseries-module">The <em>timeseries</em> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-plot-module">The <em>plot</em> module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew.html">What’s New</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Developer docs</a><ul>
      <li>Previous: <a href="pvfactors_demo.html" title="previous chapter">pvfactors: Jupyter notebook guide</a></li>
      <li>Next: <a href="../whatsnew.html" title="next chapter">What’s New</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="details-on-classes-and-modules">
<span id="class-details"></span><h1>Details on classes and modules<a class="headerlink" href="#details-on-classes-and-modules" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-array-class">
<h2>The <em>Array</em> class<a class="headerlink" href="#the-array-class" title="Permalink to this headline">¶</a></h2>
<p>More details on the array class and its methods.</p>
<dl class="class">
<dt id="pvarray.Array">
<em class="property">class </em><code class="descclassname">pvarray.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>n_pvrows=3</em>, <em>pvrow_height=1.5</em>, <em>pvrow_width=1.0</em>, <em>array_tilt=20.0</em>, <em>array_azimuth=180.0</em>, <em>solar_zenith=0.0</em>, <em>solar_azimuth=180.0</em>, <em>rho_ground=0.2</em>, <em>rho_back_pvrow=0.05</em>, <em>rho_front_pvrow=0.03</em>, <em>gcr=0.3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line">Create the array object. This will call the <a class="reference internal" href="#pvarray.Array.update_view_factors" title="pvarray.Array.update_view_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_view_factors()</span></code></a></div>
<div class="line">method which creates the shapely geometry and calculate the view</div>
<div class="line">factors based on the inputs.</div>
<div class="line">Azimuth angles are counted positive going East from North. E.g. 0 deg is</div>
<div class="line">North and 90 degrees is East.</div>
<div class="line">#FIXME The array azimuth uses a different convention than pvlib: for the</div>
<div class="line">torque-tube axis to be oriented South-North, the array azimuth angle</div>
<div class="line">needs to be 90 deg. And 0 deg would be East-West orientation.</div>
<div class="line">This assumes an equal spacing (or GCR) between all pv rows.</div>
<div class="line">This assumes that all pv rows have identical rotation angles.</div>
<div class="line">This assumes that all pv rows are at the same elevation (only x-values</div>
<div class="line">change from a pv row to another).</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_pvrows</strong> (<em>int</em>) – number of PV rows in parallel</li>
<li><strong>pvrow_height</strong> (<em>float</em>) – height of PV rows, measured from ground to
center [meters]</li>
<li><strong>pvrow_width</strong> (<em>float</em>) – width of PV rows, in the considered 2D
dimension [meters]</li>
<li><strong>array_tilt</strong> (<em>float</em>) – tilt angle of the whole array. All PV rows must
have the same tilt angle [degrees]</li>
<li><strong>array_azimuth</strong> (<em>float</em>) – azimuth angle of the whole array. All PV
rows must have the same azimuth angle [degrees]</li>
<li><strong>solar_zenith</strong> (<em>float</em>) – zenith angle of the sun [degrees]</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – azimuth angle of the sun [degrees]</li>
<li><strong>rho_ground</strong> (<em>float</em>) – ground albedo</li>
<li><strong>rho_back_pvrow</strong> (<em>float</em>) – reflectivity of PV row’s back surface</li>
<li><strong>rho_front_pvrow</strong> (<em>float</em>) – reflectivity of PV row’s front surface</li>
<li><strong>kwargs</strong> – possible options are: <code class="docutils literal notranslate"><span class="pre">pvrow_class</span></code> if the user wants
to specify its own PV Row class; <code class="docutils literal notranslate"><span class="pre">cut</span></code> if the user wants to
discretize some pv rows, e.g. [(0, 5, ‘front’), (4, 2, ‘front’)]
will discretize the front side of the first PV row into 5 segments,
and the 5th pv row… ; <code class="docutils literal notranslate"><span class="pre">pvrow_distance</span></code> if the user wants to
specify the distance between PV rows instead of GCR [DEPRECATED];
<code class="docutils literal notranslate"><span class="pre">calculate_front_circ_horizon_shading</span></code> is a boolean that indicates
weather to calculate front circumsolar &amp; horizon band shading or not;
<code class="docutils literal notranslate"><span class="pre">circumsolar_angle</span></code> would be the full (not half) angle of the
circumsolar disk; <code class="docutils literal notranslate"><span class="pre">horizon_band_angle</span></code> would be the horizon band
elevation angle</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pvarray.Array.apply_front_circumsolar_horizon_shading">
<code class="descname">apply_front_circumsolar_horizon_shading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.apply_front_circumsolar_horizon_shading" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate what amount of diffuse shading is happening on the
circumsolar and horizon band components and apply it to all ‘front’
surfaces of pvrows. It just updates the corresponding irradiance
terms that will be used in the mathematical formulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.apply_horizon_band_shading">
<code class="descname">apply_horizon_band_shading</code><span class="sig-paren">(</span><em>pvrow_side</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.apply_horizon_band_shading" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the amount of diffuse shading happening on the horizon
band components for the ‘back’ pvrow surfaces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pvrow_side</strong> (<em>str</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.calculate_interrow_direct_shading">
<code class="descname">calculate_interrow_direct_shading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.calculate_interrow_direct_shading" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate inter-row direct shading and  break up PV row objects into
shaded and unshaded parts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None; updating <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code> with additional entries</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.calculate_radiosities_perez">
<code class="descname">calculate_radiosities_perez</code><span class="sig-paren">(</span><em>solar_zenith</em>, <em>solar_azimuth</em>, <em>array_tilt</em>, <em>array_azimuth</em>, <em>dni</em>, <em>luminance_isotropic</em>, <em>luminance_circumsolar</em>, <em>poa_horizon</em>, <em>poa_circumsolar</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.calculate_radiosities_perez" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve linear system of equations to calculate radiosity terms based on
the specified inputs and using Perez diffuse light transposition model
pre-calculated values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>solar_zenith</strong> (<em>float</em>) – zenith angle of the sun [degrees]</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – azimuth angle of the sun [degrees]</li>
<li><strong>array_tilt</strong> (<em>float</em>) – tilt angle of the whole array. All PV rows must
have the same tilt angle [degrees]</li>
<li><strong>array_azimuth</strong> (<em>float</em>) – azimuth angle of the whole array. All PV
rows must have the same azimuth angle [degrees]</li>
<li><strong>dni</strong> (<em>float</em>) – direct normal irradiance [W/m2]</li>
<li><strong>luminance_isotropic</strong> (<em>float</em>) – luminance of the isotropic part of the
sky dome [W/m2/sr]</li>
<li><strong>luminance_circumsolar</strong> (<em>float</em>) – luminance of the circumsolar part of
the sky dome [W/m2/sr]</li>
<li><strong>poa_horizon</strong> (<em>float</em>) – plane-of-array horizon component of the
irradiance as calculated by Perez for the front surface of a PV row
[W/m2]</li>
<li><strong>poa_circumsolar</strong> (<em>float</em>) – plane-of-array circumsolar component of
the irradiance as calculated by Perez for the front surface of a PV
row [W/m2]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None; updating <code class="xref py py-attr docutils literal notranslate"><span class="pre">surface_registry</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.calculate_sky_and_reflection_components">
<code class="descname">calculate_sky_and_reflection_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.calculate_sky_and_reflection_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming that the calculation of view factors and radiosity terms is
completed, calculate the irradiance components of the isotropic sky dome
and of the reflections from surrounding surfaces (pv rows and ground)
for all the surfaces in the PV array.
Update the surface registry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_ill_ground">
<code class="descname">create_ill_ground</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_ill_ground" title="Permalink to this definition">¶</a></dt>
<dd><p>Create illuminated ground areas between shadows and add them to the
line registry.
The function assumes that the shadows are ordered and sorted from left
to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None; updated <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_pvrow_shadows">
<code class="descname">create_pvrow_shadows</code><span class="sig-paren">(</span><em>solar_zenith</em>, <em>solar_azimuth</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_pvrow_shadows" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the PV row shadows cast on the ground. Since the PV array is in
2D, the approach here is to project the solar vector into the 2D plane
considered here. The next step is to calculate the shadow boundaries
based on the PV row position and the solar angle using some geometry.
The calculated shadow lines are added to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code>.
Assumption: if there is direct shading between rows, this will mean that
there is one continuous shadow on the ground formed by all the
trackers’ shadows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>solar_zenith</strong> (<em>float</em>) – sun’s zenith angle</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – sun’s azimuth angle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_pvrows_array">
<code class="descname">create_pvrows_array</code><span class="sig-paren">(</span><em>n_pvrows</em>, <em>pvrow_height</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_pvrows_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create list of PV rows in array, counting from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_pvrows</strong> (<em>int</em>) – number of PV rows in the array</li>
<li><strong>pvrow_height</strong> (<em>float</em>) – height of the PV rows, measured from ground
to the center of the row</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">pvrow.PVRowLine</span></code> objects, for now.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_remaining_illum_ground">
<code class="descname">create_remaining_illum_ground</code><span class="sig-paren">(</span><em>edge_points</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_remaining_illum_ground" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the remaining illuminated parts of the ground, at the outer edges
of the PV array.
The areas are supposed to be infinite, but for model simplicity they
are implemented as being very large (fixed values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edge_points</strong> (<em>list</em>) – <strong>sorted</strong> list of <code class="xref py py-class docutils literal notranslate"><span class="pre">shapely.Point</span></code>
objects representing the intersection of PV row lines and the ground</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None; updating <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_surface_registry">
<code class="descname">create_surface_registry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_surface_registry" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <code class="docutils literal notranslate"><span class="pre">surface_registry</span></code> attribute from <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code>. One of
the big differences is that the <code class="docutils literal notranslate"><span class="pre">surface_registry</span></code> is able to
distinguish the two sides of a PV row object. For instance it will
make sure to record that only one side of a PV row can have direct
shading, or that only one side may be discretized. The names of the two
sides are ‘front’ and ‘back’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None; creating <code class="docutils literal notranslate"><span class="pre">surface_registry</span></code> attribute</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.create_view_matrix">
<code class="descname">create_view_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.create_view_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the <code class="docutils literal notranslate"><span class="pre">view_matrix</span></code> and the <code class="docutils literal notranslate"><span class="pre">args_matrix</span></code>, which records which
surface sees which surface, as well as the “type” of view that it is,
and potential “obstructing” objects.
The logic here can be a little complex, and there may be ways to
simplify it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">view_matrix</span></code>, <code class="docutils literal notranslate"><span class="pre">args_matrix</span></code>; both <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code>
objects and containing the “type” of views of each finite surface to
the others, and additional arguments like “obstructing” objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.discretize_surfaces">
<code class="descname">discretize_surfaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.discretize_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretize PV row surfaces using the inputs provided in the class
constructor. New entries will be added to the <code class="docutils literal notranslate"><span class="pre">surface_registry</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None; updating <code class="xref py py-attr docutils literal notranslate"><span class="pre">surface_registry</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.find_edge_points">
<code class="descname">find_edge_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.find_edge_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge points are defined as the virtual intersection of the pvrow
lines and the ground. They determine what part of the ground the front
surface of the pvrow sees, and same for the back surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">shapely.Point</span></code> objects; the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">line_registry</span></code> is also updated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.update_irradiance_terms_perez">
<code class="descname">update_irradiance_terms_perez</code><span class="sig-paren">(</span><em>solar_zenith</em>, <em>solar_azimuth</em>, <em>array_tilt</em>, <em>array_azimuth</em>, <em>dni</em>, <em>luminance_isotropic</em>, <em>luminance_circumsolar</em>, <em>poa_horizon</em>, <em>poa_circumsolar</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.update_irradiance_terms_perez" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the irradiance source terms of all surfaces using values
pre-calculated from the Perez transposition model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>solar_zenith</strong> (<em>float</em>) – zenith angle of the sun [degrees]</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – azimuth angle of the sun [degrees]</li>
<li><strong>array_tilt</strong> (<em>float</em>) – tilt angle of the whole array. All PV rows must
have the same tilt angle [degrees]</li>
<li><strong>array_azimuth</strong> (<em>float</em>) – azimuth angle of the whole array. All PV
rows must have the same azimuth angle [degrees]</li>
<li><strong>dni</strong> (<em>float</em>) – direct normal irradiance [W/m2]</li>
<li><strong>luminance_isotropic</strong> (<em>float</em>) – luminance of the isotropic part of the
sky dome [W/m2/sr]</li>
<li><strong>luminance_circumsolar</strong> (<em>float</em>) – luminance of the circumsolar part of
the sky dome [W/m2/sr]</li>
<li><strong>poa_horizon</strong> (<em>float</em>) – plane-of-array horizon component of the
irradiance as calculated by Perez for the front surface of a PV row
[W/m2]</li>
<li><strong>poa_circumsolar</strong> (<em>float</em>) – plane-of-array circumsolar component of
the irradiance as calculated by Perez for the front surface of a PV
row [W/m2]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.update_irradiance_terms_simple">
<code class="descname">update_irradiance_terms_simple</code><span class="sig-paren">(</span><em>solar_zenith</em>, <em>solar_azimuth</em>, <em>array_tilt</em>, <em>array_azimuth</em>, <em>dni</em>, <em>dhi</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.update_irradiance_terms_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the irradiance source terms of all surfaces by assuming that
the whole sky dome is isotropic (no diffuse sky dome decomposition).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>solar_zenith</strong> (<em>float</em>) – zenith angle of the sun [degrees]</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – azimuth angle of the sun [degrees]</li>
<li><strong>array_tilt</strong> (<em>float</em>) – tilt angle of the whole array. All PV rows must
have the same tilt angle [degrees]</li>
<li><strong>array_azimuth</strong> (<em>float</em>) – azimuth angle of the whole array. All PV
rows must have the same azimuth angle [degrees]</li>
<li><strong>dni</strong> (<em>float</em>) – direct normal irradiance [W/m2]</li>
<li><strong>dhi</strong> (<em>float</em>) – diffuse horizontal irradiance [W/m2]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.update_reflectivity_matrix">
<code class="descname">update_reflectivity_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.update_reflectivity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Update new surface registry with reflectivity values for all surfaces,
and calculate inverse of the reflectivity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pvarray.Array.update_view_factors">
<code class="descname">update_view_factors</code><span class="sig-paren">(</span><em>solar_zenith</em>, <em>solar_azimuth</em>, <em>array_tilt</em>, <em>array_azimuth</em><span class="sig-paren">)</span><a class="headerlink" href="#pvarray.Array.update_view_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new line and surface registries based on new inputs, and re-cal-
culate the view factor matrix of the updated system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>solar_zenith</strong> (<em>float</em>) – zenith angle of the sun</li>
<li><strong>solar_azimuth</strong> (<em>float</em>) – azimuth angle of the sun</li>
<li><strong>array_tilt</strong> (<em>float</em>) – tilt angle of the whole array. All PV rows must
have the same tilt angle</li>
<li><strong>array_azimuth</strong> (<em>float</em>) – azimuth angle of the whole array. All PV
rows must have the same azimuth angle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-timeseries-module">
<h2>The <em>timeseries</em> module<a class="headerlink" href="#the-timeseries-module" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">More details on some functions of the <code class="docutils literal notranslate"><span class="pre">timeseries</span></code> module. It is designed to help the user run timeseries simulations.</div>
</div>
<div class="line-block">
<div class="line">The functions below should be the most useful.</div>
</div>
<dl class="function">
<dt id="timeseries.calculate_radiosities_serially_perez">
<code class="descclassname">timeseries.</code><code class="descname">calculate_radiosities_serially_perez</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#timeseries.calculate_radiosities_serially_perez" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate timeseries results of simulation: run both custom Perez
diffuse light transposition calculations and <code class="docutils literal notranslate"><span class="pre">pvarray.Array</span></code> timeseries
calculation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – tuple of arguments used to run the timeseries calculation.
List in order: <code class="docutils literal notranslate"><span class="pre">pvarray_parameters</span></code>, <code class="docutils literal notranslate"><span class="pre">timestamps</span></code>,
<code class="docutils literal notranslate"><span class="pre">solar_zenith</span></code>, <code class="docutils literal notranslate"><span class="pre">solar_azimuth</span></code>, <code class="docutils literal notranslate"><span class="pre">array_tilt</span></code>, <code class="docutils literal notranslate"><span class="pre">array_azimuth</span></code>,
<code class="docutils literal notranslate"><span class="pre">dni</span></code>, <code class="docutils literal notranslate"><span class="pre">dhi</span></code>.
All 1-dimensional arrays.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">df_registries</span></code>, <code class="docutils literal notranslate"><span class="pre">df_custom_perez</span></code>; dataframes containing
the concatenated and timestamped <code class="docutils literal notranslate"><span class="pre">pvarray.Array.surface_registry</span></code>
values, and the custom Perez inputs used for it.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">both class:<cite>pandas.DataFrame</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="timeseries.calculate_radiosities_parallel_perez">
<code class="descclassname">timeseries.</code><code class="descname">calculate_radiosities_parallel_perez</code><span class="sig-paren">(</span><em>pvarray_parameters</em>, <em>timestamps</em>, <em>solar_zenith</em>, <em>solar_azimuth</em>, <em>array_tilt</em>, <em>array_azimuth</em>, <em>dni</em>, <em>dhi</em>, <em>n_processes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#timeseries.calculate_radiosities_parallel_perez" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate timeseries results of simulation in parallel:
run both custom Perez diffuse light transposition calculations and
<code class="docutils literal notranslate"><span class="pre">pvarray.Array</span></code> timeseries calculation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pvarray_parameters</strong> (<em>dict</em>) – parameters used to instantiate
<code class="docutils literal notranslate"><span class="pre">pvarray.Array</span></code> class</li>
<li><strong>timestamps</strong> (<em>array-like</em>) – simulation timestamps</li>
<li><strong>solar_zenith</strong> (<em>array-like</em>) – solar zenith angles</li>
<li><strong>solar_azimuth</strong> (<em>array-like</em>) – solar azimuth angles</li>
<li><strong>array_tilt</strong> (<em>array-like</em>) – pv module tilt angles</li>
<li><strong>array_azimuth</strong> (<em>array-like</em>) – pv array azimuth angles</li>
<li><strong>dni</strong> (<em>array-like</em>) – values for direct normal irradiance</li>
<li><strong>dhi</strong> (<em>array-like</em>) – values for diffuse horizontal irradiance</li>
<li><strong>n_processes</strong> (<em>int</em>) – (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> = use all) number of
processes to use. Default value will be the total number of processors
on the machine.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">df_registries</span></code>, <code class="docutils literal notranslate"><span class="pre">df_custom_perez</span></code>; dataframes containing
the concatenated and timestamped <code class="docutils literal notranslate"><span class="pre">pvarray.Array.surface_registry</span></code>
values, and the custom Perez inputs used for it.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">both class:<cite>pandas.DataFrame</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-plot-module">
<h2>The <em>plot</em> module<a class="headerlink" href="#the-plot-module" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">The functions below will help the users visualize the constructed PV arrays using the <code class="docutils literal notranslate"><span class="pre">shapely</span></code> geometries:</div>
</div>
<dl class="function">
<dt id="plot.plot_pvarray">
<code class="descclassname">plot.</code><code class="descname">plot_pvarray</code><span class="sig-paren">(</span><em>ax</em>, <em>pvarray</em>, <em>line_types_selected=None</em>, <em>fontsize=20</em><span class="sig-paren">)</span><a class="headerlink" href="#plot.plot_pvarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a 2D PV array from a <a class="reference internal" href="#pvarray.Array" title="pvarray.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">pvarray.Array</span></code></a> using its
<code class="xref py py-attr docutils literal notranslate"><span class="pre">pvarray.Array.surface_registry</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ax</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code> object to use for the plot</li>
<li><strong>pvarray</strong> (<a class="reference internal" href="#pvarray.Array" title="pvarray.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">pvarray.Array</span></code></a>) – object containing the surface registry as attribute</li>
<li><strong>line_types_selected</strong> (<em>list</em>) – parameter used to select a subset of
‘line_type’ to plot; e.g. ‘pvrow’ or ‘ground’</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None (<code class="docutils literal notranslate"><span class="pre">ax</span></code> is updated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="plot.plot_array_from_registry">
<code class="descclassname">plot.</code><code class="descname">plot_array_from_registry</code><span class="sig-paren">(</span><em>ax</em>, <em>registry</em>, <em>line_types_selected=None</em>, <em>fontsize=20</em><span class="sig-paren">)</span><a class="headerlink" href="#plot.plot_array_from_registry" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a 2D PV array using the <code class="docutils literal notranslate"><span class="pre">shapely</span></code> geometry objects located in
a <a class="reference internal" href="#pvarray.Array" title="pvarray.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">pvarray.Array</span></code></a> surface registry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ax</strong> (<em>matplotlib.axes.Axes</em>) – axes to use for the plot</li>
<li><strong>registry</strong> (<em>pd.DataFrame</em>) – registry containing geometries  to plot</li>
<li><strong>line_types_selected</strong> (<em>list</em>) – parameter used to select a subset of
‘line_type’ to plot; e.g. ‘pvrow’ or ‘ground’</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None (<code class="docutils literal notranslate"><span class="pre">ax</span></code> is updated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;Copyright 2016, SunPower Corporation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/developer/class_details.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/SunPower/pvfactors" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>