

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pvfactors.pvarray &mdash; pvfactors 0.1.5+24.g5ce1047 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pvfactors
          

          
            
            <img src="../../_static/sp_2014_logo_all_white_LARGE.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew.html">Whatâ€™s New</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pvfactors</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pvfactors.pvarray</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pvfactors.pvarray</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;PV array classes&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">pvfactors</span> <span class="k">import</span> <span class="n">PVFactorsArrayUpdateException</span>
<span class="kn">from</span> <span class="nn">pvfactors.pvcore</span> <span class="k">import</span> <span class="p">(</span><span class="n">LinePVArray</span><span class="p">,</span>
                              <span class="n">find_edge_point</span><span class="p">,</span> <span class="n">Y_GROUND</span><span class="p">,</span>
                              <span class="n">MAX_X_GROUND</span><span class="p">,</span> <span class="n">MIN_X_GROUND</span><span class="p">,</span>
                              <span class="n">calculate_circumsolar_shading</span><span class="p">,</span>
                              <span class="n">calculate_horizon_band_shading</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pvfactors.pvrow</span> <span class="k">import</span> <span class="n">PVRowLine</span>
<span class="kn">from</span> <span class="nn">pvfactors.view_factors</span> <span class="k">import</span> <span class="n">ViewFactorCalculator</span><span class="p">,</span> <span class="n">VIEW_DICT</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="k">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pvfactors.pvgeometry</span> <span class="k">import</span> <span class="n">PVGeometry</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">Registry</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">notnull</span><span class="p">,</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">pvlib.tools</span> <span class="k">import</span> <span class="n">cosd</span><span class="p">,</span> <span class="n">sind</span>
<span class="kn">from</span> <span class="nn">pvlib.irradiance</span> <span class="k">import</span> <span class="n">aoi</span> <span class="k">as</span> <span class="n">aoi_function</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">LOGGER</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">X_ORIGIN_PVROWS</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">DEFAULT_EDGE_PT_X</span> <span class="o">=</span> <span class="n">X_ORIGIN_PVROWS</span>
<span class="n">DELTA_MAX_MIN_GROUND_WHEN_TOO_SMALL_BIG</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">DEFAULT_CIRCUMSOLAR_ANGLE</span> <span class="o">=</span> <span class="mf">30.</span>
<span class="n">DEFAULT_HORIZON_BAND_ANGLE</span> <span class="o">=</span> <span class="mf">6.5</span>


<div class="viewcode-block" id="ArrayBase"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.ArrayBase.html#pvfactors.pvarray.ArrayBase">[docs]</a><span class="k">class</span> <span class="nc">ArrayBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;``ArrayBase`` exists for future developments of the model. It is the</span>
<span class="sd">     base class for PV arrays that will contain all the boiler plate code</span>
<span class="sd">     shared by sub classes like ``Array``, or for instance more complex</span>
<span class="sd">     PV array classes with varying GCR values, or non-flat ground, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_pvrows : int</span>
<span class="sd">        number of PV rows in PV array</span>
<span class="sd">    pvrow_height : float</span>
<span class="sd">        height of PV rows</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">registry_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># LinePVArray keys</span>
        <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;line_type&#39;</span><span class="p">,</span> <span class="s1">&#39;shaded&#39;</span><span class="p">,</span> <span class="s1">&#39;pvrow_index&#39;</span><span class="p">,</span>
        <span class="c1"># Geometry cols</span>
        <span class="s1">&#39;pvrow_segment_index&#39;</span><span class="p">,</span> <span class="s1">&#39;index_pvrow_neighbor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;edge_point&#39;</span><span class="p">,</span> <span class="s1">&#39;surface_side&#39;</span><span class="p">,</span> <span class="s1">&#39;surface_centroid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;line_registry_index&#39;</span><span class="p">,</span>
        <span class="c1"># Irradiance terms</span>
        <span class="s1">&#39;reflectivity&#39;</span><span class="p">,</span> <span class="s1">&#39;irradiance_term&#39;</span><span class="p">,</span> <span class="s1">&#39;direct_term&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isotropic_term&#39;</span><span class="p">,</span> <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">,</span>
        <span class="s1">&#39;horizon_term&#39;</span><span class="p">,</span> <span class="s1">&#39;circumsolar_shading_pct&#39;</span><span class="p">,</span>
        <span class="s1">&#39;horizon_band_shading_pct&#39;</span><span class="p">,</span> <span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;qinc&#39;</span><span class="p">]</span>
    <span class="n">registry_numeric_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;pvrow_index&#39;</span><span class="p">,</span> <span class="s1">&#39;pvrow_segment_index&#39;</span><span class="p">,</span> <span class="s1">&#39;index_pvrow_neighbor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;line_registry_index&#39;</span><span class="p">,</span> <span class="s1">&#39;reflectivity&#39;</span><span class="p">,</span> <span class="s1">&#39;irradiance_term&#39;</span><span class="p">,</span>
        <span class="s1">&#39;direct_term&#39;</span><span class="p">,</span> <span class="s1">&#39;isotropic_term&#39;</span><span class="p">,</span> <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">,</span>
        <span class="s1">&#39;horizon_term&#39;</span><span class="p">,</span> <span class="s1">&#39;circumsolar_shading_pct&#39;</span><span class="p">,</span>
        <span class="s1">&#39;horizon_band_shading_pct&#39;</span><span class="p">,</span> <span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;qinc&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="ArrayBase.__init__"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.ArrayBase.html#pvfactors.pvarray.ArrayBase.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span> <span class="n">pvrow_height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pvrows</span> <span class="o">=</span> <span class="n">n_pvrows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_height</span> <span class="o">=</span> <span class="n">pvrow_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_registry</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view_factor_calculator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vf_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_reflectivity_matrix</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">initialize_registry</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Create an empty line registry based on the property keys of PV Array</span>
<span class="sd">        lines.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        registry object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the line and surface registries</span>
        <span class="c1"># TODO: line_pvarray_keys should not be dependent on specific classes</span>
        <span class="c1"># like ``LinePVArray()``</span>
        <span class="n">registry</span> <span class="o">=</span> <span class="n">Registry</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">ArrayBase</span><span class="o">.</span><span class="n">registry_cols</span><span class="p">)</span>
        <span class="n">registry</span><span class="p">[</span><span class="n">ArrayBase</span><span class="o">.</span><span class="n">registry_numeric_cols</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">registry</span><span class="p">[</span><span class="n">ArrayBase</span><span class="o">.</span><span class="n">registry_numeric_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">registry</span>

    <span class="k">def</span> <span class="nf">create_pvrows_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args :</span>

<span class="sd">        **kwargs :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tilt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pvrow</span><span class="p">,</span> <span class="s1">&#39;tilt&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">tilt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The property &#39;tilt&#39; is not defined for Array&quot;</span>
                                 <span class="s2">&quot; object&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pvrow_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pvrow</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gcr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">pvrow</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The property &#39;pvrow_distance&#39; is not &quot;</span>
                                 <span class="s2">&quot;defined for Array object&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Array"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.html#pvfactors.pvarray.Array">[docs]</a><span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">ArrayBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the array object. This will call the :meth:`update_view_factors`</span>
<span class="sd">    method which creates the shapely geometry and calculate the view</span>
<span class="sd">    factors based on the inputs.</span>
<span class="sd">    | Azimuth angles are counted positive going East from North. E.g. 0 deg is</span>
<span class="sd">    North and 90 degrees is East.</span>
<span class="sd">    | This assumes an equal spacing (or GCR) between all pv rows.</span>
<span class="sd">    | This assumes that all pv rows have identical rotation angles.</span>
<span class="sd">    | This assumes that all pv rows are at the same elevation (only x-values</span>
<span class="sd">    | change from a pv row to another).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_pvrows : int</span>
<span class="sd">        number of PV rows in parallel</span>
<span class="sd">    pvrow_height : float</span>
<span class="sd">        height of PV rows, measured from ground to</span>
<span class="sd">        center [meters]</span>
<span class="sd">    pvrow_width : float</span>
<span class="sd">        width of PV rows, in the considered 2D</span>
<span class="sd">        dimension [meters]</span>
<span class="sd">    surface_tilt : float</span>
<span class="sd">        Surface tilt angles in decimal degrees.</span>
<span class="sd">        surface_tilt must be &gt;=0 and &lt;=180.</span>
<span class="sd">        The tilt angle is defined as degrees from horizontal</span>
<span class="sd">        (e.g. surface facing up = 0, surface facing horizon = 90)</span>
<span class="sd">    surface_azimuth : float</span>
<span class="sd">        The azimuth of the rotated panel,</span>
<span class="sd">        determined by projecting the vector normal to the panel&#39;s surface</span>
<span class="sd">        to the earth&#39;s surface [degrees].</span>
<span class="sd">    solar_zenith : float</span>
<span class="sd">        zenith angle of the sun [degrees]</span>
<span class="sd">    solar_azimuth : float</span>
<span class="sd">        azimuth angle of the sun [degrees]</span>
<span class="sd">    rho_ground : float</span>
<span class="sd">        ground albedo</span>
<span class="sd">    rho_back_pvrow : float</span>
<span class="sd">        reflectivity of PV row&#39;s back surface</span>
<span class="sd">    rho_front_pvrow : float</span>
<span class="sd">        reflectivity of PV row&#39;s front surface</span>
<span class="sd">    gcr : float</span>
<span class="sd">        ground coverage ratio of the PV array</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        possible options are: ``pvrow_class`` if the user wants</span>
<span class="sd">        to specify its own PV Row class; ``cut`` if the user wants to</span>
<span class="sd">        discretize some pv rows, e.g. [(0, 5, &#39;front&#39;), (4, 2, &#39;back&#39;)]</span>
<span class="sd">        will discretize the front surface of the first PV row into 5 segments,</span>
<span class="sd">        and the back surface of the 5th pv row into 2 segments;</span>
<span class="sd">        ``calculate_front_circ_horizon_shading`` is a boolean that indicates</span>
<span class="sd">        whether to calculate front circumsolar &amp; horizon band shading or not;</span>
<span class="sd">        ``circumsolar_angle`` would be the full (not half) angle of the</span>
<span class="sd">        circumsolar disk; ``horizon_band_angle`` would be the horizon band</span>
<span class="sd">        elevation angle</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_pvrow_class</span> <span class="o">=</span> <span class="n">PVRowLine</span>
    <span class="n">_view_factor_calculator</span> <span class="o">=</span> <span class="n">ViewFactorCalculator</span>

<div class="viewcode-block" id="Array.__init__"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.html#pvfactors.pvarray.Array.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pvrow_height</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">pvrow_width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">surface_tilt</span><span class="o">=</span><span class="mf">20.</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="o">=</span><span class="mf">180.</span><span class="p">,</span> <span class="n">solar_zenith</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">solar_azimuth</span><span class="o">=</span><span class="mf">180.</span><span class="p">,</span> <span class="n">rho_ground</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">rho_back_pvrow</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">rho_front_pvrow</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">gcr</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Set up all the initial class attributes</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_pvrows</span><span class="p">,</span> <span class="n">pvrow_height</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_class</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pvrow_class&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pvrow_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view_factor_calculator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view_factor_calculator</span><span class="p">()</span>
        <span class="c1"># Fixed array parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gcr</span> <span class="o">=</span> <span class="n">gcr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_width</span> <span class="o">=</span> <span class="n">pvrow_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_ground</span> <span class="o">=</span> <span class="n">rho_ground</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_back_pvrow</span> <span class="o">=</span> <span class="n">rho_back_pvrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho_front_pvrow</span> <span class="o">=</span> <span class="n">rho_front_pvrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cut&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circumsolar_angle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circumsolar_angle&#39;</span><span class="p">,</span>
                                            <span class="n">DEFAULT_CIRCUMSOLAR_ANGLE</span><span class="p">)</span>  <span class="c1"># deg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">horizon_band_angle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;horizon_band_angle&#39;</span><span class="p">,</span>
                                             <span class="n">DEFAULT_HORIZON_BAND_ANGLE</span><span class="p">)</span>  <span class="c1"># deg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_front_circ_horizon_shading</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;calculate_front_circ_horizon_shading&#39;</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circumsolar_model</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circumsolar_model&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;uniform_disk&#39;</span><span class="p">)</span>
        <span class="c1"># Variable array parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_zenith</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_azimuth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_azimuth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_tilt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">illum_ground_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_direct_shading</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Update array from initial parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_view_factors</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span>
                                 <span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.update_view_factors"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.update_view_factors.html#pvfactors.pvarray.Array.update_view_factors">[docs]</a>    <span class="k">def</span> <span class="nf">update_view_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span> <span class="n">surface_tilt</span><span class="p">,</span>
                            <span class="n">surface_azimuth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new line and surface registries based on new inputs, and re-cal-</span>
<span class="sd">        culate the view factor matrix of the updated system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solar_zenith : float</span>
<span class="sd">            zenith angle of the sun [in deg]</span>
<span class="sd">        solar_azimuth : float</span>
<span class="sd">            azimuth angle of the sun [in deg]</span>
<span class="sd">        surface_tilt : float</span>
<span class="sd">            Surface tilt angles in decimal degrees.</span>
<span class="sd">            surface_tilt must be &gt;=0 and &lt;=180.</span>
<span class="sd">            The tilt angle is defined as degrees from horizontal</span>
<span class="sd">            (e.g. surface facing up = 0, surface facing horizon = 90)</span>
<span class="sd">        surface_azimuth : float</span>
<span class="sd">            The azimuth of the rotated panel,</span>
<span class="sd">            determined by projecting the vector normal to the panel&#39;s surface</span>
<span class="sd">            to the earth&#39;s surface [degrees].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_registry</span><span class="p">()</span>
        <span class="c1"># Check on which side the light is incident</span>
        <span class="n">sun_on_front_surface</span> <span class="o">=</span> <span class="n">aoi_function</span><span class="p">(</span><span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span>
                                            <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">90</span>

        <span class="c1"># Update array parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_azimuth</span> <span class="o">=</span> <span class="n">surface_azimuth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_tilt</span> <span class="o">=</span> <span class="n">surface_tilt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_zenith</span> <span class="o">=</span> <span class="n">solar_zenith</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_azimuth</span> <span class="o">=</span> <span class="n">solar_azimuth</span>

        <span class="c1"># ------- Line creation: returning the line registry</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;...building line registry&quot;</span><span class="p">)</span>
        <span class="c1"># Create the PV rows / structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pvrows_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pvrows</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_height</span><span class="p">)</span>

        <span class="c1"># Create the ground and the shadows on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_pvrow_shadows</span><span class="p">(</span><span class="n">surface_azimuth</span><span class="p">,</span> <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_ill_ground</span><span class="p">()</span>
        <span class="n">edge_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_remaining_illum_ground</span><span class="p">(</span><span class="n">edge_points</span><span class="p">)</span>
        <span class="c1"># Assuming the edge points are ordered</span>
        <span class="c1"># --- Add edge points to geometries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">split_ground_geometry_from_edge_points</span><span class="p">(</span>
            <span class="n">edge_points</span><span class="p">)</span>

        <span class="c1"># ------- Surface creation: returning the surface registry, a line may</span>
        <span class="c1"># represent 2 surfaces (front and back)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;...building surface registry&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_surface_registry</span><span class="p">()</span>

        <span class="c1"># -------- Interrow shading</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_direct_shading</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;...calculating interrow shading&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_interrow_direct_shading</span><span class="p">(</span><span class="n">sun_on_front_surface</span><span class="p">)</span>

        <span class="c1"># -------- Update the surface areas (lengths) after shading calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">:,</span> <span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">length</span>

        <span class="c1"># ------- View factors: define the surface views and calculate view</span>
        <span class="c1"># factors</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;...building view matrix and finding obstructions&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view_matrix</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">args_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_view_matrix</span><span class="p">()</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;...calculating view factors&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vf_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view_factor_calculator</span><span class="o">.</span><span class="n">calculate_view_factors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">view_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_matrix</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Array.update_irradiance_terms_perez"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.update_irradiance_terms_perez.html#pvfactors.pvarray.Array.update_irradiance_terms_perez">[docs]</a>    <span class="k">def</span> <span class="nf">update_irradiance_terms_perez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span>
                                      <span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span> <span class="n">dni</span><span class="p">,</span>
                                      <span class="n">luminance_isotropic</span><span class="p">,</span>
                                      <span class="n">luminance_circumsolar</span><span class="p">,</span>
                                      <span class="n">poa_horizon</span><span class="p">,</span> <span class="n">poa_circumsolar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the irradiance source terms of all surfaces using values</span>
<span class="sd">        pre-calculated from the Perez transposition model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solar_zenith : float</span>
<span class="sd">            zenith angle of the sun [degrees]</span>
<span class="sd">        solar_azimuth : float</span>
<span class="sd">            azimuth angle of the sun [degrees]</span>
<span class="sd">        surface_tilt : float</span>
<span class="sd">            Surface tilt angles in decimal degrees.</span>
<span class="sd">            surface_tilt must be &gt;=0 and &lt;=180.</span>
<span class="sd">            The tilt angle is defined as degrees from horizontal</span>
<span class="sd">            (e.g. surface facing up = 0, surface facing horizon = 90)</span>
<span class="sd">        surface_azimuth : float</span>
<span class="sd">            azimuth angle of the PV surfaces. All PV</span>
<span class="sd">            surfaces must have the same azimuth angle [degrees]</span>
<span class="sd">        dni : float</span>
<span class="sd">            direct normal irradiance [W/m2]</span>
<span class="sd">        luminance_isotropic : float</span>
<span class="sd">            luminance of the isotropic part of</span>
<span class="sd">            the sky dome [W/m2/sr]</span>
<span class="sd">        luminance_circumsolar : float</span>
<span class="sd">            luminance of the circumsolar part</span>
<span class="sd">            of the sky dome [W/m2/sr]</span>
<span class="sd">        poa_horizon : float</span>
<span class="sd">            plane-of-array horizon component of the</span>
<span class="sd">            irradiance as calculated by Perez for the front surface of a PV row</span>
<span class="sd">            [W/m2]</span>
<span class="sd">        poa_circumsolar : float</span>
<span class="sd">            plane-of-array circumsolar component of</span>
<span class="sd">            the irradiance as calculated by Perez for the front surface of a PV</span>
<span class="sd">            row [W/m2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;horizon_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;direct_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;surface_centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">centroid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;circumsolar_shading_pct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;horizon_band_shading_pct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># --- Calculate terms</span>
        <span class="n">dni_ground</span> <span class="o">=</span> <span class="n">dni</span> <span class="o">*</span> <span class="n">cosd</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">)</span>
        <span class="n">circumsolar_ground</span> <span class="o">=</span> <span class="n">luminance_circumsolar</span>
        <span class="c1"># FIXME: only works for pvrows as lines</span>
        <span class="n">aoi_frontsurface</span> <span class="o">=</span> <span class="n">aoi_function</span><span class="p">(</span><span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span>
                                        <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">)</span>

        <span class="c1"># --- Assign terms to surfaces</span>
        <span class="c1"># Illuminated ground</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span><span class="p">),</span>
            <span class="s1">&#39;direct_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dni_ground</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span><span class="p">),</span>
            <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circumsolar_ground</span>

        <span class="c1"># -- PVRow surfaces</span>

        <span class="c1"># Set the horizon diffuse light</span>
        <span class="c1"># TODO: poa_horizon should not be negative... but it can be in the</span>
        <span class="c1"># Perez model from pvlib</span>
        <span class="n">poa_horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">poa_horizon</span><span class="p">)</span>

        <span class="c1"># Add poa horizon contribution to all pvrow surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">),</span>
            <span class="s1">&#39;horizon_term&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">poa_horizon</span>

        <span class="c1"># Apply horizon band shading for the pvrow back surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_horizon_band_shading</span><span class="p">(</span><span class="s1">&#39;back&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aoi_frontsurface</span> <span class="o">&lt;=</span> <span class="mf">90.</span><span class="p">:</span>
            <span class="c1"># Direct light is incident on front side of pvrows</span>
            <span class="n">dni_pvrow</span> <span class="o">=</span> <span class="n">dni</span> <span class="o">*</span> <span class="n">cosd</span><span class="p">(</span><span class="n">aoi_frontsurface</span><span class="p">)</span>
            <span class="n">circumsolar_pvrow</span> <span class="o">=</span> <span class="n">poa_circumsolar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">),</span>
                <span class="s1">&#39;direct_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dni_pvrow</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">),</span>
                <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circumsolar_pvrow</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_front_circ_horizon_shading</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_front_circumsolar_horizon_shading</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Direct light is incident on back side of pvrows</span>
            <span class="n">aoi_backsurface</span> <span class="o">=</span> <span class="mf">180.</span> <span class="o">-</span> <span class="n">aoi_frontsurface</span>
            <span class="n">dni_pvrow</span> <span class="o">=</span> <span class="n">dni</span> <span class="o">*</span> <span class="n">cosd</span><span class="p">(</span><span class="n">aoi_backsurface</span><span class="p">)</span>
            <span class="n">vf_circumsolar_backsurface</span> <span class="o">=</span> <span class="p">(</span><span class="n">cosd</span><span class="p">(</span><span class="n">aoi_backsurface</span><span class="p">)</span>
                                          <span class="o">/</span> <span class="n">cosd</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">))</span>
            <span class="n">circumsolar_pvrow</span> <span class="o">=</span> <span class="p">(</span><span class="n">luminance_circumsolar</span>
                                 <span class="o">*</span> <span class="n">vf_circumsolar_backsurface</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
                <span class="s1">&#39;direct_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dni_pvrow</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="o">~</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shaded</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
                <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circumsolar_pvrow</span>

        <span class="c1"># Sum up the terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;irradiance_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;direct_term&#39;</span><span class="p">]</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;horizon_term&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Set up irradiance terms vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">irradiance_term</span>
                                      <span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Isotropic sky dome luminance value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">luminance_isotropic</span></div>

<div class="viewcode-block" id="Array.apply_horizon_band_shading"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.apply_horizon_band_shading.html#pvfactors.pvarray.Array.apply_horizon_band_shading">[docs]</a>    <span class="k">def</span> <span class="nf">apply_horizon_band_shading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pvrow_side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the amount of diffuse shading happening on the horizon</span>
<span class="sd">        band components for the &#39;back&#39; pvrow surfaces</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pvrow_side : str</span>
<span class="sd">            Side of pvrow on which to apply horizon band shading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">slice_registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="n">pvrow_side</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="n">notnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">index_pvrow_neighbor</span><span class="p">),</span> <span class="p">:]</span>

        <span class="c1"># Calculate the shading angle in 2D plane for each back surface</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">slice_registry</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">row_point</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">surface_centroid</span>
            <span class="n">neighbor_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">index_pvrow_neighbor</span><span class="p">)]</span><span class="o">.</span><span class="n">highest_point</span>
            <span class="n">shading_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span>
                <span class="p">(</span><span class="n">neighbor_point</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">row_point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">neighbor_point</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">row_point</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="c1"># shading_angle = 0.</span>
            <span class="n">percent_horizon_shading</span> <span class="o">=</span> <span class="n">calculate_horizon_band_shading</span><span class="p">(</span>
                <span class="n">shading_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon_band_angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;horizon_term&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                <span class="mf">1.</span> <span class="o">-</span> <span class="n">percent_horizon_shading</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;horizon_band_shading_pct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">percent_horizon_shading</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.apply_front_circumsolar_horizon_shading"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.apply_front_circumsolar_horizon_shading.html#pvfactors.pvarray.Array.apply_front_circumsolar_horizon_shading">[docs]</a>    <span class="k">def</span> <span class="nf">apply_front_circumsolar_horizon_shading</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate what amount of diffuse shading is happening on the</span>
<span class="sd">        circumsolar and horizon band components and apply it to all &#39;front&#39;</span>
<span class="sd">        surfaces of pvrows. It just updates the corresponding irradiance</span>
<span class="sd">        terms that will be used in the mathematical formulation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">slice_registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="n">notnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">index_pvrow_neighbor</span><span class="p">),</span> <span class="p">:]</span>

        <span class="c1"># Calculate the solar and circumsolar elevation angles in 2D plane</span>
        <span class="n">solar_2d_elevation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">lower_angle_circumsolar</span> <span class="o">=</span> <span class="p">(</span><span class="n">solar_2d_elevation</span>
                                   <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">circumsolar_angle</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

        <span class="c1"># Calculate the shading angle in 2D plane as well for each surface</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">slice_registry</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">row_point</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">surface_centroid</span>
            <span class="n">neighbor_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">index_pvrow_neighbor</span><span class="p">)]</span><span class="o">.</span><span class="n">highest_point</span>
            <span class="n">shading_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span>
                <span class="p">(</span><span class="n">neighbor_point</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">row_point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">neighbor_point</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">row_point</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">percentage_circ_angle_covered</span> <span class="o">=</span> <span class="p">((</span><span class="n">shading_angle</span> <span class="o">-</span>
                                              <span class="n">lower_angle_circumsolar</span><span class="p">)</span>
                                             <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">circumsolar_angle</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.</span>
            <span class="n">percent_circ_shading</span> <span class="o">=</span> <span class="n">calculate_circumsolar_shading</span><span class="p">(</span>
                <span class="n">percentage_circ_angle_covered</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">circumsolar_model</span><span class="p">)</span>
            <span class="n">percent_horizon_shading</span> <span class="o">=</span> <span class="n">calculate_horizon_band_shading</span><span class="p">(</span>
                <span class="n">shading_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon_band_angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;circumsolar_term&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                <span class="mf">1.</span> <span class="o">-</span> <span class="n">percent_circ_shading</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;horizon_term&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                <span class="mf">1.</span> <span class="o">-</span> <span class="n">percent_horizon_shading</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;circumsolar_shading_pct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">percent_circ_shading</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;horizon_band_shading_pct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">percent_horizon_shading</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.update_reflectivity_matrix"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.update_reflectivity_matrix.html#pvfactors.pvarray.Array.update_reflectivity_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">update_reflectivity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update new surface registry with reflectivity values for all surfaces,</span>
<span class="sd">        and calculate inverse of the reflectivity matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;reflectivity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Assign reflectivity to all surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reflectivity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_ground</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">),</span>
            <span class="s1">&#39;reflectivity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_front_pvrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
            <span class="s1">&#39;reflectivity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_back_pvrow</span>
        <span class="c1"># Create inv reflectivity matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_reflectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">reflectivity</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Array.calculate_radiosities_perez"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.calculate_radiosities_perez.html#pvfactors.pvarray.Array.calculate_radiosities_perez">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_radiosities_perez</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span> <span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span>
            <span class="n">dni</span><span class="p">,</span> <span class="n">luminance_isotropic</span><span class="p">,</span> <span class="n">luminance_circumsolar</span><span class="p">,</span> <span class="n">poa_horizon</span><span class="p">,</span>
            <span class="n">poa_circumsolar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve linear system of equations to calculate radiosity terms based on</span>
<span class="sd">        the specified inputs and using Perez diffuse light transposition model</span>
<span class="sd">        pre-calculated values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solar_zenith : float</span>
<span class="sd">            zenith angle of the sun [degrees]</span>
<span class="sd">        solar_azimuth : float</span>
<span class="sd">            azimuth angle of the sun [degrees]</span>
<span class="sd">        surface_tilt : float</span>
<span class="sd">            Surface tilt angles in decimal degrees.</span>
<span class="sd">            surface_tilt must be &gt;=0 and &lt;=180.</span>
<span class="sd">            The tilt angle is defined as degrees from horizontal</span>
<span class="sd">            (e.g. surface facing up = 0, surface facing horizon = 90)</span>
<span class="sd">        surface_azimuth : float</span>
<span class="sd">            The azimuth of the rotated panel,</span>
<span class="sd">            determined by projecting the vector normal to the panel&#39;s surface</span>
<span class="sd">            to the earth&#39;s surface [degrees].</span>
<span class="sd">        dni : float</span>
<span class="sd">            direct normal irradiance [W/m2]</span>
<span class="sd">        luminance_isotropic : float</span>
<span class="sd">            luminance of the isotropic part of</span>
<span class="sd">            the sky dome [W/m2/sr]</span>
<span class="sd">        luminance_circumsolar : float</span>
<span class="sd">            luminance of the circumsolar part</span>
<span class="sd">            of the sky dome [W/m2/sr]</span>
<span class="sd">        poa_horizon : float</span>
<span class="sd">            plane-of-array horizon component of the</span>
<span class="sd">            irradiance as calculated by Perez for the front surface of a PV row</span>
<span class="sd">            [W/m2]</span>
<span class="sd">        poa_circumsolar : float</span>
<span class="sd">            plane-of-array circumsolar component of</span>
<span class="sd">            the irradiance as calculated by Perez for the front surface of a PV</span>
<span class="sd">            row [W/m2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the array configuration</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_view_factors</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span>
                                     <span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PVFactorsArrayUpdateException</span><span class="p">(</span>
                <span class="s2">&quot;Could not calculate shapely array or view factors because of &quot;</span>
                <span class="s2">&quot;error: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_irradiance_terms_perez</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">,</span>
                                           <span class="n">surface_tilt</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span> <span class="n">dni</span><span class="p">,</span>
                                           <span class="n">luminance_isotropic</span><span class="p">,</span>
                                           <span class="n">luminance_circumsolar</span><span class="p">,</span>
                                           <span class="n">poa_horizon</span><span class="p">,</span> <span class="n">poa_circumsolar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_reflectivity_matrix</span><span class="p">()</span>

        <span class="c1"># Do calculation</span>
        <span class="n">a_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_reflectivity_matrix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">vf_matrix</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span><span class="p">)</span>
        <span class="n">qinc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vf_matrix</span><span class="p">,</span> <span class="n">q0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span>
        <span class="c1"># Assign to surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;q0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;qinc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qinc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_sky_and_reflection_components</span><span class="p">()</span></div>

<div class="viewcode-block" id="Array.calculate_sky_and_reflection_components"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.calculate_sky_and_reflection_components.html#pvfactors.pvarray.Array.calculate_sky_and_reflection_components">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_sky_and_reflection_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assuming that the calculation of view factors and radiosity terms is</span>
<span class="sd">        completed, calculate the irradiance components of the isotropic sky</span>
<span class="sd">        dome and of the reflections from surrounding surfaces</span>
<span class="sd">        (pv rows and ground) for all the surfaces in the PV array.</span>
<span class="sd">        Update the surface registry.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># FIXME: not very robust, make sure to have a test for it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;isotropic_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vf_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">irradiance_terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;reflection_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;qinc&#39;</span><span class="p">]</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;irradiance_term&#39;</span><span class="p">]</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="p">[</span><span class="s1">&#39;isotropic_term&#39;</span><span class="p">]</span>
        <span class="p">)</span></div>

<span class="c1"># ------- Line creation</span>
<div class="viewcode-block" id="Array.create_pvrows_array"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_pvrows_array.html#pvfactors.pvarray.Array.create_pvrows_array">[docs]</a>    <span class="k">def</span> <span class="nf">create_pvrows_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">,</span> <span class="n">pvrow_height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create list of PV rows in array, counting from left to right.</span>
<span class="sd">        In the 2D plane that will be considered, no matter the array azimuth</span>
<span class="sd">        angle will be, POSITIVE tilts will lead to pv surfaces tilted to the</span>
<span class="sd">        LEFT, and NEGATIVE tilts will lead to PV surfaces tilted to the RIGHT.</span>
<span class="sd">        So in the case of a single axis tracker, the direction of the torque</span>
<span class="sd">        tube will be the normal vector going out of the 2D plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_pvrows : int</span>
<span class="sd">            number of PV rows in the array</span>
<span class="sd">        pvrow_height : float</span>
<span class="sd">            height of the PV rows, measured from ground</span>
<span class="sd">            to the center of the row</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of :py:class:`pvfactors.pvrow.PVRowLine` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assume that all rows are at the same height</span>
        <span class="n">y_center</span> <span class="o">=</span> <span class="n">pvrow_height</span>
        <span class="n">x_center</span> <span class="o">=</span> <span class="n">X_ORIGIN_PVROWS</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">surface_tilt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_width</span><span class="p">)</span>
        <span class="n">pvrows</span> <span class="o">=</span> <span class="p">[</span><span class="n">pvrow</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_pvrows</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcr</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_pvrows</span><span class="p">):</span>
                <span class="n">x_center</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">distance</span>
                <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_class</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span>
                    <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_tilt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_width</span><span class="p">)</span>
                <span class="n">pvrows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pvrow</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pvrows</span></div>

<div class="viewcode-block" id="Array.create_pvrow_shadows"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_pvrow_shadows.html#pvfactors.pvarray.Array.create_pvrow_shadows">[docs]</a>    <span class="k">def</span> <span class="nf">create_pvrow_shadows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_azimuth</span><span class="p">,</span>
                             <span class="n">solar_zenith</span><span class="p">,</span> <span class="n">solar_azimuth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the PV row shadows cast on the ground. Since the PV array is in</span>
<span class="sd">        2D, the approach here is to project the solar vector into the 2D plane</span>
<span class="sd">        considered here. The next step is to calculate the shadow boundaries</span>
<span class="sd">        based on the PV row position and the solar angle using some geometry.</span>
<span class="sd">        The calculated shadow lines are added to the :attr:`line_registry`.</span>
<span class="sd">        Assumption: if there is direct shading between rows, this will mean</span>
<span class="sd">        that there is one continuous shadow on the ground formed by all the</span>
<span class="sd">        trackers&#39; shadows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface_azimuth : float</span>
<span class="sd">            The azimuth of the rotated panel,</span>
<span class="sd">            determined by projecting the vector normal to the panel&#39;s surface</span>
<span class="sd">            to the earth&#39;s surface [degrees].</span>
<span class="sd">        solar_zenith : float</span>
<span class="sd">            sun&#39;s zenith angle</span>
<span class="sd">        solar_azimuth : float</span>
<span class="sd">            sun&#39;s azimuth angle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Projection of 3d solar vector onto the cross section of the systems:</span>
        <span class="c1"># which is the 2d plane we are considering: needed to calculate shadows</span>
        <span class="c1"># Remember that the 2D plane is such that the direction of the torque</span>
        <span class="c1"># tube vector goes out of (and normal to) the 2D plane, such that</span>
        <span class="c1"># positive tilt angles will have the PV surfaces tilted to the LEFT</span>
        <span class="c1"># and vice versa</span>
        <span class="n">solar_2d_vector</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># a drawing really helps understand the following</span>
            <span class="o">-</span> <span class="n">sind</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">)</span> <span class="o">*</span> <span class="n">cosd</span><span class="p">(</span><span class="n">surface_azimuth</span> <span class="o">-</span> <span class="n">solar_azimuth</span><span class="p">),</span>
            <span class="n">cosd</span><span class="p">(</span><span class="n">solar_zenith</span><span class="p">)]</span>
        <span class="c1"># for a line of equation a*x + b*y + c = 0, we calculate intercept c</span>
        <span class="c1"># and can derive x_0 such that crosses with line y = 0: x_0 = - c / a</span>
        <span class="n">list_x_shadows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_shadow_line_pvarrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># TODO: speed improvement can be made by translating the shadow</span>
        <span class="c1"># boundaries and removing most of the for loop calculation</span>
        <span class="n">pvrow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx_pvrow</span><span class="p">,</span> <span class="n">pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_direct_shading</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">x1_shadow</span><span class="p">,</span> <span class="n">x2_shadow</span> <span class="o">=</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">get_shadow_bounds</span><span class="p">(</span><span class="n">solar_2d_vector</span><span class="p">)</span>
            <span class="n">list_x_shadows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x1_shadow</span><span class="p">,</span> <span class="n">x2_shadow</span><span class="p">))</span>
            <span class="c1"># Check if there is direct shading: if yes, the shadows will</span>
            <span class="c1"># be grouped into one continuous shadow</span>
            <span class="k">if</span> <span class="n">idx_pvrow</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">list_x_shadows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">list_x_shadows</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">has_direct_shading</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Get the bounds of the big shadow</span>
                    <span class="n">x1_shadow</span> <span class="o">=</span> <span class="n">list_x_shadows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">x2_shadow</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="o">.</span><span class="n">get_shadow_bounds</span><span class="p">(</span><span class="n">solar_2d_vector</span><span class="p">))</span>
                    <span class="n">shadow_geometry</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x1_shadow</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                                  <span class="p">(</span><span class="n">x2_shadow</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
                    <span class="n">shadow_line_pvarray</span> <span class="o">=</span> <span class="n">LinePVArray</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">shadow_geometry</span><span class="p">,</span>
                                                      <span class="n">line_type</span><span class="o">=</span><span class="s1">&#39;ground&#39;</span><span class="p">,</span>
                                                      <span class="n">shaded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">list_shadow_line_pvarrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">shadow_line_pvarray</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">pvrow_inner_loop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">:</span>
                        <span class="n">pvrow_inner_loop</span><span class="o">.</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">shadow_line_pvarray</span>
                    <span class="k">break</span>
            <span class="n">shadow_geometry</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x1_shadow</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x2_shadow</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="n">shadow_line_pvarray</span> <span class="o">=</span> <span class="n">LinePVArray</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">shadow_geometry</span><span class="p">,</span>
                                              <span class="n">line_type</span><span class="o">=</span><span class="s1">&#39;ground&#39;</span><span class="p">,</span>
                                              <span class="n">shaded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">list_shadow_line_pvarrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shadow_line_pvarray</span><span class="p">)</span>
            <span class="n">pvrow</span><span class="o">.</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">shadow_line_pvarray</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span> <span class="o">=</span> <span class="n">solar_2d_vector</span>
        <span class="n">pvrow</span><span class="o">.</span><span class="n">shadow_line_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">list_shadow_line_pvarrays</span><span class="p">))</span></div>

<div class="viewcode-block" id="Array.create_ill_ground"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_ill_ground.html#pvfactors.pvarray.Array.create_ill_ground">[docs]</a>    <span class="k">def</span> <span class="nf">create_ill_ground</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create illuminated ground areas between shadows and add them to the</span>
<span class="sd">        line registry.</span>
<span class="sd">        The function assumes that the shadows are ordered and sorted from left</span>
<span class="sd">        to right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df_bounds_shadows</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span>
                             <span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="p">[</span><span class="s1">&#39;line_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span><span class="p">)</span>
                                  <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">shaded</span><span class="p">]</span>
                             <span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">shadow_indices</span> <span class="o">=</span> <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">illum_ground_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Use the boundary pts defined by each shadow object to find the 2</span>
        <span class="c1"># points necessary to build the illuminated ground line in-between shad</span>
        <span class="k">if</span> <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">point_1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span>
                    <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="s1">&#39;maxx&#39;</span><span class="p">],</span>
                    <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="s1">&#39;maxy&#39;</span><span class="p">])</span>
                <span class="n">point_2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span>
                    <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;minx&#39;</span><span class="p">],</span>
                    <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;miny&#39;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">point_1</span> <span class="o">!=</span> <span class="n">point_2</span><span class="p">:</span>
                    <span class="c1"># If the two points are different, it means that there is</span>
                    <span class="c1"># some illum ground between the shadows -&gt; create geom</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">])</span>
                    <span class="n">ill_gnd_line_pvarray</span> <span class="o">=</span> <span class="n">LinePVArray</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                                                       <span class="n">line_type</span><span class="o">=</span><span class="s1">&#39;ground&#39;</span><span class="p">,</span>
                                                       <span class="n">shaded</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">illum_ground_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">ill_gnd_line_pvarray</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Array.find_edge_points"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.find_edge_points.html#pvfactors.pvarray.Array.find_edge_points">[docs]</a>    <span class="k">def</span> <span class="nf">find_edge_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Edge points are defined as the virtual intersection of the pvrow</span>
<span class="sd">        lines and the ground. They determine what part of the ground the front</span>
<span class="sd">        surface of the pvrow sees, and same for the back surface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of ``shapely.Point`` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># --- Find edge points</span>
        <span class="c1"># Do it for each line in the pvrows</span>
        <span class="n">edge_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Find the edge point in this case: just math at this point</span>
            <span class="n">edge_pt</span> <span class="o">=</span> <span class="n">find_edge_point</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;edge_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">edge_pt</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">edge_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_pt</span><span class="p">)</span>
        <span class="c1"># Use simple vector translation to add other edge points for other</span>
        <span class="c1"># trackers</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">new_edge_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">edge_pt</span> <span class="ow">in</span> <span class="n">edge_points</span><span class="p">:</span>
                    <span class="n">new_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">edge_pt</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrow_distance</span><span class="p">,</span>
                                      <span class="n">edge_pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                    <span class="c1"># FIXME: this is not going to work if not single line</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="s1">&#39;edge_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">new_edge_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
            <span class="n">edge_points</span> <span class="o">+=</span> <span class="n">new_edge_points</span>

        <span class="k">return</span> <span class="n">edge_points</span></div>

<div class="viewcode-block" id="Array.create_remaining_illum_ground"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_remaining_illum_ground.html#pvfactors.pvarray.Array.create_remaining_illum_ground">[docs]</a>    <span class="k">def</span> <span class="nf">create_remaining_illum_ground</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the remaining illuminated parts of the ground, at the outer</span>
<span class="sd">        edges of the PV array.</span>
<span class="sd">        The areas are supposed to be infinite, but for model simplicity they</span>
<span class="sd">        are implemented as being very large (fixed values).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_points : list</span>
<span class="sd">            **sorted** list of ``shapely.Point``</span>
<span class="sd">            objects representing the intersection of PV row lines and the</span>
<span class="sd">            ground</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_points</span><span class="p">:</span>
            <span class="n">x_min_edge_points</span> <span class="o">=</span> <span class="n">edge_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
            <span class="n">x_max_edge_points</span> <span class="o">=</span> <span class="n">edge_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_min_edge_points</span> <span class="o">=</span> <span class="n">DEFAULT_EDGE_PT_X</span>
            <span class="n">x_max_edge_points</span> <span class="o">=</span> <span class="n">DEFAULT_EDGE_PT_X</span>

        <span class="c1"># Find bounds of shadows</span>
        <span class="n">df_bounds_shadows</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span>
                             <span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="p">[</span><span class="s1">&#39;line_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span><span class="p">)</span>
                                  <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">shaded</span><span class="p">]</span>
                             <span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">shadow_indices</span> <span class="o">=</span> <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">index</span>

        <span class="c1"># Take the outermost shadow points to create the remaining illuminated</span>
        <span class="c1"># ground areas that are not between shadows</span>
        <span class="c1"># On the left side:</span>
        <span class="n">min_x_ground</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">MIN_X_GROUND</span><span class="p">,</span>
                           <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;minx&#39;</span><span class="p">]</span>
                           <span class="o">-</span> <span class="n">DELTA_MAX_MIN_GROUND_WHEN_TOO_SMALL_BIG</span><span class="p">)</span>
        <span class="n">geometry_left</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span>
            <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x_min_edge_points</span><span class="p">,</span> <span class="n">min_x_ground</span><span class="p">),</span> <span class="n">Y_GROUND</span><span class="p">),</span>
            <span class="p">(</span><span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;minx&#39;</span><span class="p">],</span>
             <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;miny&#39;</span><span class="p">]),</span>
        <span class="p">])</span>
        <span class="n">ill_gnd_left</span> <span class="o">=</span> <span class="n">LinePVArray</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geometry_left</span><span class="p">,</span>
                                   <span class="n">line_type</span><span class="o">=</span><span class="s1">&#39;ground&#39;</span><span class="p">,</span>
                                   <span class="n">shaded</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># On the right side</span>
        <span class="n">max_x_ground</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAX_X_GROUND</span><span class="p">,</span>
                           <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;maxx&#39;</span><span class="p">]</span>
                           <span class="o">+</span> <span class="n">DELTA_MAX_MIN_GROUND_WHEN_TOO_SMALL_BIG</span><span class="p">)</span>
        <span class="n">geometry_right</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span>
            <span class="p">(</span><span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;maxx&#39;</span><span class="p">],</span>
             <span class="n">df_bounds_shadows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">shadow_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;maxy&#39;</span><span class="p">]),</span>
            <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x_max_edge_points</span><span class="p">,</span> <span class="n">max_x_ground</span><span class="p">),</span> <span class="n">Y_GROUND</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">ill_gnd_right</span> <span class="o">=</span> <span class="n">LinePVArray</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geometry_right</span><span class="p">,</span>
                                    <span class="n">line_type</span><span class="o">=</span><span class="s1">&#39;ground&#39;</span><span class="p">,</span>
                                    <span class="n">shaded</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">illum_ground_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ill_gnd_left</span><span class="p">,</span> <span class="n">ill_gnd_right</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Array.calculate_interrow_direct_shading"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.calculate_interrow_direct_shading.html#pvfactors.pvarray.Array.calculate_interrow_direct_shading">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_interrow_direct_shading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sun_on_front_surface</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate inter-row direct shading and  break up PV row objects into</span>
<span class="sd">        shaded and unshaded parts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sun_on_front_surface : bool</span>
<span class="sd">            flag check if sun is incident on front surface</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the direction of shading</span>
        <span class="c1"># Direct shading calculation must be specific to the PVRow class</span>
        <span class="c1"># Shading is said &quot;forward&quot; if the shadow of the pvrow is on the</span>
        <span class="c1"># right side of the pvrow</span>
        <span class="n">shading_is_forward</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shadow</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
                              <span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">left_point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Determine if front or back surface has direct shading</span>
        <span class="k">if</span> <span class="n">sun_on_front_surface</span><span class="p">:</span>
            <span class="n">side_shaded</span> <span class="o">=</span> <span class="s1">&#39;front&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">side_shaded</span> <span class="o">=</span> <span class="s1">&#39;back&#39;</span>

        <span class="k">if</span> <span class="n">shading_is_forward</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx_pvrow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pvrows</span><span class="p">):</span>
                <span class="c1"># idx_pvrow is the index of the shaded pvrow</span>
                <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">adjacent_pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span><span class="p">]</span>
                <span class="c1"># Shadows from left to right: find vector of shadow</span>
                <span class="n">top_point_vector</span> <span class="o">=</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">highest_point</span>
                <span class="n">x1_shadow</span><span class="p">,</span> <span class="n">x2_shadow</span> <span class="o">=</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">get_shadow_bounds</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span><span class="p">)</span>
                <span class="n">ground_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x2_shadow</span><span class="p">,</span> <span class="n">Y_GROUND</span><span class="p">)</span>
                <span class="n">linestring_shadow</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">top_point_vector</span><span class="p">,</span>
                                                <span class="n">ground_point</span><span class="p">])</span>
                <span class="c1"># FIXME: we do not want to create a line_registry object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">split_pvrow_geometry</span><span class="p">(</span>
                    <span class="n">idx_pvrow</span><span class="p">,</span>
                    <span class="n">linestring_shadow</span><span class="p">,</span>
                    <span class="n">adjacent_pvrow</span><span class="o">.</span><span class="n">highest_point</span><span class="p">,</span>
                    <span class="n">side_shaded</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx_pvrow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pvrows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># idx_pvrow is the index of the shaded pvrow</span>
                <span class="n">pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">adjacent_pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">idx_pvrow</span><span class="p">]</span>
                <span class="c1"># Shadows from right to left: find vector of shadow</span>
                <span class="n">top_point_vector</span> <span class="o">=</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">highest_point</span>
                <span class="n">x1_shadow</span><span class="p">,</span> <span class="n">x2_shadow</span> <span class="o">=</span> <span class="p">(</span><span class="n">pvrow</span>
                                        <span class="o">.</span><span class="n">get_shadow_bounds</span><span class="p">(</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">solar_2d_vector</span><span class="p">)</span>
                                        <span class="p">)</span>
                <span class="n">ground_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x1_shadow</span><span class="p">,</span> <span class="n">Y_GROUND</span><span class="p">)</span>
                <span class="n">linestring_shadow</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">top_point_vector</span><span class="p">,</span> <span class="n">ground_point</span><span class="p">])</span>
                <span class="c1"># FIXME: we do not want to create a line_registry object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">split_pvrow_geometry</span><span class="p">(</span>
                    <span class="n">idx_pvrow</span><span class="p">,</span>
                    <span class="n">linestring_shadow</span><span class="p">,</span>
                    <span class="n">adjacent_pvrow</span><span class="o">.</span><span class="n">highest_point</span><span class="p">,</span>
                    <span class="n">side_shaded</span>
                <span class="p">)</span></div>

<span class="c1"># ------- Surface creation</span>
<div class="viewcode-block" id="Array.create_surface_registry"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_surface_registry.html#pvfactors.pvarray.Array.create_surface_registry">[docs]</a>    <span class="k">def</span> <span class="nf">create_surface_registry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create ``surface_registry`` attribute from :attr:`line_registry`.</span>
<span class="sd">        One of the big differences is that the ``surface_registry`` is able to</span>
<span class="sd">        distinguish the two sides of a PV row object. For instance it will</span>
<span class="sd">        make sure to record that only one side of a PV row can have direct</span>
<span class="sd">        shading, or that only one side may be discretized. The names of the two</span>
<span class="sd">        sides are &#39;front&#39; and &#39;back&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">front_surface_registry</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_registry</span><span class="p">)</span>
        <span class="n">front_surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;surface_side&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;front&#39;</span>
        <span class="c1"># Create pvrow back surfaces</span>
        <span class="n">back_surface_registry</span> <span class="o">=</span> <span class="n">front_surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">front_surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">back_surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;surface_side&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;back&#39;</span>
        <span class="c1"># Merge two registries together</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">front_surface_registry</span>
            <span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">back_surface_registry</span><span class="p">)</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">line_registry_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Discretize surfaces specified by user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discretize_surfaces</span><span class="p">()</span></div>

<div class="viewcode-block" id="Array.discretize_surfaces"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.discretize_surfaces.html#pvfactors.pvarray.Array.discretize_surfaces">[docs]</a>    <span class="k">def</span> <span class="nf">discretize_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Discretize PV row surfaces using the inputs provided in the class</span>
<span class="sd">        constructor. New entries will be added to the ``surface_registry``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">:</span>
            <span class="n">pvrow_index</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_segments</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">side</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">pvrow_index</span><span class="p">]</span><span class="o">.</span><span class="n">calculate_cut_points</span><span class="p">(</span><span class="n">n_segments</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">cut_pvrow_geometry</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">[</span><span class="n">pvrow_index</span><span class="p">]</span><span class="o">.</span><span class="n">cut_points</span><span class="p">,</span> <span class="n">pvrow_index</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span>
                <span class="n">count_segments</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<span class="c1"># ------- View matrix creation</span>
<div class="viewcode-block" id="Array.create_view_matrix"><a class="viewcode-back" href="../../developer/generated/pvfactors.pvarray.Array.create_view_matrix.html#pvfactors.pvarray.Array.create_view_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">create_view_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the ``view_matrix`` and the ``args_matrix``, which records which</span>
<span class="sd">        surface sees which surface, as well as the &quot;type&quot; of view that it is,</span>
<span class="sd">        and potential &quot;obstructing&quot; objects.</span>
<span class="sd">        The logic here can be a little complex, and there may be ways to</span>
<span class="sd">        simplify it.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        view_matrix : np.ndarray</span>
<span class="sd">            2D matrix containing the &#39;type&#39; of view from each finite surface</span>
<span class="sd">            to the others</span>
<span class="sd">        args_matrix : np.ndarray</span>
<span class="sd">            2D matrix containing additional arguments like &quot;obstructing&quot;</span>
<span class="sd">            objects, and related to that type of view</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># view matrix will contain the view relationships between each surface</span>
        <span class="n">view_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># args matrix will contain the obstructng objects of views for instance</span>
        <span class="n">args_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">args_matrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># All surface indices need to be grouped and tracked for simplification</span>
        <span class="n">indices_front_pvrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">indices_back_pvrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;pvrow&#39;</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">indices_ground</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">line_type</span> <span class="o">==</span> <span class="s1">&#39;ground&#39;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">index_sky_dome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">view_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># The ground will always see the sky</span>
        <span class="c1"># Use broadcasting for assigning values to subarrays of view matrix</span>
        <span class="c1"># Could also use np.ix_</span>
        <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_ground</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">index_sky_dome</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;ground_sky&quot;</span><span class="p">]</span>

        <span class="c1"># The pvrow front surface is always either flat or pointing to the</span>
        <span class="c1"># left by design</span>
        <span class="n">pvrow_is_flat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_tilt</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pvrow_is_flat</span><span class="p">:</span>
            <span class="c1"># Only back surface can see the ground</span>
            <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_back_pvrows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="n">indices_ground</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;back_gnd&quot;</span><span class="p">]</span>
            <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_ground</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="n">indices_back_pvrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;gnd_back&quot;</span><span class="p">]</span>
            <span class="c1"># The front side only sees the sky</span>
            <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_front_pvrows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="n">index_sky_dome</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;front_sky&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find ground centroid values</span>
            <span class="n">ground_registry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices_ground</span><span class="p">,</span>
                                                        <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Need to create a registry to use geometry functions like &quot;bounds&quot;</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">Registry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
            <span class="n">ground_registry</span><span class="p">[</span>
                <span class="s1">&#39;x_centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">centroids</span><span class="o">.</span><span class="n">pvgeometry</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">minx</span><span class="p">)</span>

            <span class="c1"># All pvrow surfaces see the sky dome</span>
            <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_back_pvrows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="n">index_sky_dome</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;back_sky&quot;</span><span class="p">]</span>
            <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_front_pvrows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                        <span class="n">index_sky_dome</span><span class="p">]</span> <span class="o">=</span> <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;front_sky&quot;</span><span class="p">]</span>

            <span class="c1"># Initialize last indices for interrow views</span>
            <span class="n">last_indices_back_pvrow</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># PVRow neighbors for each PVRow</span>
            <span class="n">pvrows_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pvrow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvrows</span><span class="p">):</span>
                <span class="c1"># Get indices specific to pvrow</span>
                <span class="n">indices_back_pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">)</span>
                <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="n">indices_front_pvrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">)</span>
                <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># --- Find the lines that front and back see on the ground</span>
                <span class="c1"># Get edge point of this pvrow</span>
                <span class="n">edge_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices_front_pvrow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="s1">&#39;edge_point&#39;</span><span class="p">]</span>
                <span class="c1"># Find the ground lines laying on the right or left side of pt</span>
                <span class="n">indices_ground_right_of_edge_pt</span> <span class="o">=</span> <span class="n">ground_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">edge_pt</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">ground_registry</span><span class="o">.</span><span class="n">x_centroid</span>
                <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="n">indices_ground_left_of_edge_pt</span> <span class="o">=</span> <span class="n">ground_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">edge_pt</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">ground_registry</span><span class="o">.</span><span class="n">x_centroid</span>
                <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Initialize variables for obstructions and Hottel&#39;s method</span>
                <span class="n">right_neighbor_pvrow</span> <span class="o">=</span> <span class="n">pvrows_list</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">left_neighbor_pvrow</span> <span class="o">=</span> <span class="n">pvrows_list</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">indices_ground_seen_by_front</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">indices_ground_seen_by_back</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># The projection of normal of front surface onto ground points</span>
                <span class="c1"># to the left (by design of PVRow objects)</span>
                <span class="n">indices_ground_seen_by_front</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">indices_ground_left_of_edge_pt</span><span class="p">)</span>
                <span class="n">indices_ground_seen_by_back</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">indices_ground_right_of_edge_pt</span>
                <span class="p">)</span>
                <span class="c1"># Finding any obstructing pv rows</span>
                <span class="n">front_obstruction_pvrow</span> <span class="o">=</span> <span class="n">left_neighbor_pvrow</span>
                <span class="n">back_obstruction_pvrow</span> <span class="o">=</span> <span class="n">right_neighbor_pvrow</span>
                <span class="c1"># Save the PV row neighbor index values</span>
                <span class="k">if</span> <span class="n">right_neighbor_pvrow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
                        <span class="s1">&#39;index_pvrow_neighbor&#39;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">right_neighbor_pvrow</span><span class="o">.</span><span class="n">index</span>
                <span class="k">if</span> <span class="n">left_neighbor_pvrow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">pvrow_index</span> <span class="o">==</span> <span class="n">pvrow</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_registry</span><span class="o">.</span><span class="n">surface_side</span> <span class="o">==</span> <span class="s1">&#39;front&#39;</span><span class="p">),</span>
                        <span class="s1">&#39;index_pvrow_neighbor&#39;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">left_neighbor_pvrow</span><span class="o">.</span><span class="n">index</span>

                <span class="c1"># Front and back sides see different lines on the ground</span>
                <span class="k">if</span> <span class="n">indices_ground_seen_by_back</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Define the views in the matrix</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_back_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_ground_seen_by_back</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;back_gnd_obst&quot;</span><span class="p">])</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_ground_seen_by_back</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_back_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;gnd_back_obst&quot;</span><span class="p">])</span>
                    <span class="c1"># Define the obstructing pv rows in the matrix</span>
                    <span class="n">args_matrix</span><span class="p">[</span><span class="n">indices_back_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_ground_seen_by_back</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">back_obstruction_pvrow</span><span class="p">)</span>
                    <span class="n">args_matrix</span><span class="p">[</span><span class="n">indices_ground_seen_by_back</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_back_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">back_obstruction_pvrow</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">indices_ground_seen_by_front</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_front_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_ground_seen_by_front</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;front_gnd_obst&quot;</span><span class="p">])</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_ground_seen_by_front</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_front_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;gnd_front_obst&quot;</span><span class="p">])</span>
                    <span class="c1"># Define the obstructing pv rows in the matrix</span>
                    <span class="n">args_matrix</span><span class="p">[</span><span class="n">indices_front_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_ground_seen_by_front</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">front_obstruction_pvrow</span><span class="p">)</span>
                    <span class="n">args_matrix</span><span class="p">[</span><span class="n">indices_ground_seen_by_front</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_front_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">front_obstruction_pvrow</span><span class="p">)</span>

                <span class="c1"># --- Find the views between neighbor pv rows</span>
                <span class="k">if</span> <span class="n">last_indices_back_pvrow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># pvrow to pvrow view</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">last_indices_back_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">indices_front_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;pvrows&quot;</span><span class="p">])</span>
                    <span class="n">view_matrix</span><span class="p">[</span><span class="n">indices_front_pvrow</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                <span class="n">last_indices_back_pvrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">VIEW_DICT</span><span class="p">[</span><span class="s2">&quot;pvrows&quot;</span><span class="p">])</span>

                <span class="c1"># Save last indices for next pvrow interaction</span>
                <span class="n">last_indices_back_pvrow</span> <span class="o">=</span> <span class="n">indices_back_pvrow</span>

        <span class="k">return</span> <span class="n">view_matrix</span><span class="p">,</span> <span class="n">args_matrix</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Copyright 2016, SunPower Corporation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>